---
title: "Numerical calculation of the EM Hankel integrals"
jupyter: python3
---
This section covers the implementation of the numerical calculation of Hankel integrals typically encountered in dipole induction over a layered half-space.

As usual, we will restrict ourselves to the vertical magnetic dipole (VMD).

We will demonstrate the computational method using the vertical component $B_z$ of the magnetic field as an example.

Finally, we will use our implementation to simulate a measurement with the helicopter EM system of the BGR Hannover.

```{python}
#| echo: false
import numpy as np
import matplotlib.pyplot as plt
```


We have obtained the following integrals for $z \le 0$:

$$
\begin{align}
	E_\varphi & = -\frac{i \omega \mu m}{4 \pi} 
	\left[
    \frac{r}{R^3} +
	\int_0^\infty \frac{\lambda - \lambda_1}{\lambda + \lambda_1}\lambda 
	e^{-\lambda h}e^{\lambda z}J_1(\lambda r)\, \dd\lambda
	\right] \\
    B_r & = \frac{\mu_0 m}{4 \pi}
	\left[
	\frac{3r(z+h)}{R^5} -
	\int_0^\infty \frac{\lambda - \lambda_1}{\lambda + \lambda_1}\lambda^2
	e^{-\lambda h}e^{\lambda z}J_1(\lambda r)\, \dd\lambda
	\right] \\
    B_z & = \frac{\mu_0 m}{4 \pi}
	\left[
	\frac{3(z+h)^2 - R^2}{R^5} +
	\int_0^\infty \frac{\lambda - \lambda_1}{\lambda + \lambda_1}\lambda^2
	e^{-\lambda h}e^{\lambda z}J_0(\lambda r)\, \dd\lambda
	\right]
\end{align}
$$ {#eq-fields-in-air}


The first terms in the brackets of @eq-fields-in-air describe the geometric damping of the source field in free space.
These terms are trivial to calculate.

The contribution to the field components in $z<0$ caused by induction in $z>0$ is provided by the integral expressions in the brackets.

They have the general form
$$
\begin{equation}
g(r) = \int_0^\infty f(\lambda, z) J_\nu(\lambda r)\, \dd\lambda, \qquad \nu > -1
\end{equation}
$$
with $\nu$ indicating the order of the Bessel function.

## The oscillating nature of the integrands

To evaluate, e.g., the component $B_z$, one needs the function $f(\lambda, z)$ as
$$
f(\lambda, z) = \frac{\lambda - \lambda_1}{\lambda + \lambda_1}\lambda^2
e^{-\lambda h}e^{\lambda z}
$$

As an example, we choose a uniform halfspace with

- conductivity $\sigma_1=0.01$ S/m
- frequency $f = 100$ Hz
- transmitter and receiver in plane $z=0$
- offset $r = 100$ m.

The surface admittance $\lambda_1 = \sqrt{\lambda^2 + i \omega \mu_0 \sigma_1}$ will be calculated using the function `lambda_1` given below.


This is the `Python` implementation of the admittance of the uniform halfspace, $\lambda_1$:

```{python}
def lambda_1(lam, sigma, mu, f):
    omega = 2 * np.pi * f
    mu0 = np.pi * 4e-7
    alpha = np.sqrt(lam**2 + 1j * omega * mu * sigma)
    return alpha / mu0
```

Given these definitions, we are now able to evaluate the complete integrand functions in @eq-fields-in-air. 

To this end, we first illustrate the integrand graphically:

```{python}
nlam = 801
lam = np.logspace(0, 5, nlam, endpoint=True)
r = 100.0
freq = 100.0
sigma = 0.01
mu = np.pi * 4e-7

f = [(l - lambda_1(l, sigma, mu, freq)) / (l + lambda_1(l, sigma, mu, freq)) * l**2 for l in lam]

fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(6,4))
ax1.loglog(lam, np.abs(np.real(f)))
ax1.set_ylabel(r'$| \mathrm{Re}(f(\lambda,z))|$')
ax1.grid(True)

ax2.loglog(lam, np.abs(np.imag(f)))
ax2.set_xlabel(r'$\lambda$')
ax2.set_ylabel(r'$| \mathrm{Im}(f(\lambda,z))|$')
ax2.set_ylim(1e-12, 1e-10)
ax2.grid(True)
```
As we see from the above illustration, the behaviour of $f(\lambda,z)$ itself does not impose any numerical problems to the integration.

The following graphs show the real and imaginary part of the _complete integrand_:

```{python}
from scipy.special import j0
fig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(6,4))
ax1.semilogx(lam, np.real(f) * j0(lam * r))
ax1.grid(True)
ax1.set_title(r'$\mathrm{Re}(f(\lambda)) J_0(\lambda r)$')
ax2.semilogx(lam, np.imag(f) * j0(lam * r))
ax2.grid(True)
ax2.set_title(r'$\mathrm{Im}(f(\lambda)) J_0(\lambda r)$')
ax2.set_xlabel(r'$\lambda$');
```
We observe that the numerical integration will be a major challenge.

This is due to the following reasons:

* The Bessel function brings into play an _oscillation_ of the integrand
* The upper limit of integration is at _infinity_ 

In practice, the following three numerical techniques have proven effective:

1. Fast Hankel Transform (FHT)
2. Gauss quadrature with an adapted weighting function
3. Representation of the integrand function by Chebyshew polynomials

In the following, we briefly outline the idea of the FHT.

## The Fast Hankel Transform

Important work on this problem has been done by @ghosh1971, @johansen1979, @anderson1982fast, @christensen1990, among others.

The method is based on the following idea:

To cover the range of $\lambda$ from $0$ to $\infty$ as quickly as possible, we take the following *variable transformation*:

$$\begin{equation}
\begin{split}
x & = \log(r/r_0) \\
y & = -\log(\lambda r_0), \qquad r_0 > 0 \\
G(x) & = r g(r) \\
F(y) & = f(\lambda) \\
H(x) & = e^x J_\nu(e^x)
\end{split}
\end{equation}$$

Then, the integral for computing $g(r)$, i.e.,

$$\begin{equation}
g(r) = \int_0^\infty f(\lambda, z) J_\nu(\lambda r)\, \dd\lambda, \qquad \nu > -1.
\end{equation}$$

can be rewritten as a convolution integral, such that

$$\begin{equation}
G(x) = \int_{-\infty}^\infty F(y) H(x - y) \dd y.
\end{equation}$$

For discrete values of $F$ with $F_n := F(y_n)$ this integral becomes a _discrete convolution_

$$\begin{equation}
G_m = \sum_{n=-\infty} ^\infty F_n H_{m-n} = \sum_{n=-\infty} ^\infty F_{m-n} H_{n}
\end{equation}$$

In the publications given at the beginning of this section, it has been explained how to compute the optimal _filter coefficients_ $\overline H_n$ with finite length $-\infty < n_1 \le n \le n_2 < \infty$.

There are two approaches to this:

1. Complex analysis: calculation of closed line integrals in the complex plane (@christensen1990, @johansen1979).
1. Least Squares fitting of filter coefficients based on known Hankel transform pairs (e.g., the well-known Sommerfeld or Weber integrals) (@anderson1982fast).

Regardless of the choice of the method for determining the coefficients
we have to implement

$$\begin{equation}
G_m = \sum_{n=n_1} ^{n_2} F_n \overline H_{m-n} = \sum_{n=n_1} ^{n_2} F_{m-n} \overline H_{n}
\end{equation}$$

using standard methods of discrete convolution.

## Numerical implementation of the convolution

We implement a `Python` function that computes the convolution:

```{python}
def convolve(fc, kernel, style="valid"):
    nc = len(fc)
    nu = len(kernel)
    n = nu + nc - 1
    result = np.zeros(n, dtype=type(kernel))
    
    for i in range(nc):
        for j in range(nu):
            result[j + i] += kernel[j] * fc[i]
    
    if style == "full":
        result = result
    elif style == "valid":
        result = result[nc - 1:n - nc + 1]
    
    return result
```

::: {.callout-note}

When the keyword `style="valid"` is specified in the call to `convolve`, then the result of the convolution is restricted to the non-zero part of the result. Otherwise, when `style="full"` is provided, the result has leading and trailing zeros (zero padding).

We always use `style="valid"` as a default.

:::

The following example confirms that our code is correct.

The convolution of two rectangular sequences results in a triangular sequence:

```{python}
f = [0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0]
h = [1, 1, 1, 1, 1]
g = convolve(h, f)
print(f)
print(h)
print(g)
```

```{python}
fig, ax = plt.subplots(1, 1, figsize=(6,2))
ax.stem(convolve(h, f, style="full"))
ax.set_title('style="full"')
ax.set_ylim((-0.25, 6.0))
ax.grid(True)
```

```{python}
fig, ax = plt.subplots(1, 1, figsize=(6,2))
ax.stem(g)
ax.set_title('style="valid"')
ax.set_ylim((-0.25, 6.0))
ax.grid(True)
```